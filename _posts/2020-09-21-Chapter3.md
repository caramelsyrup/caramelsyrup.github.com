---
title: 3.자바의 여러 가지 연산자
---

1. 기본 연산자
	* 항과 연산자 : 연산에 사용하는 값은 항. 더하기,빼기,곱하기,나누기 등은 연산자.
		* 단항 연산자 : 항이 1개인 연산자.
		* 이항 연산자 : 항이 2개인 연산자.
		* 삼항 연산자 : 항이 3개인 연산자.
	* **대입 연산자 **
		* 변수에 값을 대입하는 연산자. 가장 낮은 순위의 연산자.(마지막에 기능 실행).
		* 왼쪽변수 = 오른쪽 변수(또는 식); ( 왼쪽변수에 오른쪽변수를 대입,저장)
	* **부호 연산자**
		* +, - 두가지가 부호 연산자. 더하기,빼기 연산에도 쓰이고 음수와 양수를 나타내기도 함.
		* int num = 10;  -num 은 -10이지만 num의 값 자체가 -10으로 바뀐게 아님.
		* num = -num; 을 하게 되면, num의 값이 10에서 -10으로 바뀜.
	* **산술 연산자 **
		* 덧셈(+),뺼셈(-),곱셈(*), 나눗셈(/),나머지(%) 로 사용.
	* **증가 감소 연산자**
		* 연산자 앞이나 뒤에 사용하며, 값을 1만큼 줄이거나 1만큼 늘림.
		* val = ++num;   // 먼저 num값이 1증가한 후에, val 변수에 저장.
		* val = num++;  // val변수에 기존 num값을 저장한 후에, num 값 1 증가.
		* val = --num;    // 먼저 num값이 1 감소한 후에, val변수에 저장.
		* val = num--;   // val변수에 기존 num값을 저장한 후에, num 값 1 감소.
		* int value = 10; 
		* int num = ++value; 를 하게 되면, num은 11이 저장됨.
		* 만약 int num = value--; 를 하게 되면, num은 10이 저장됨.
	* **관계 연산자**
		* 항이 두개인 이항 연산자. 참거짓 반환.
		* **>** , 왼쪽이 크면 참, 아니면 거짓 반환.
		* **<** , 오른쪽이 크면 참, 아니면 거짓 반환.
		* **>=** , 왼쪽이 크거나 같으면 참, 아니면 거짓 반환.
		* **<=** , 오른쪽이 크거나 같으면 참, 아니면 거짓 반환.
		* **==**, 두 개의 항의 값이 같으면 참, 아니면 거짓 반환.
		* **!=**, 두 개의 항이 다르면 참, 아니면 거짓 반환.
	* **논리 연산자**
		* 명제의 참거짓과 유사.
		* **&&** 두 항이 모두 참이여야 참. 그렇지 않으면 거짓. ( AND )
		* **&#124;&#124;** 두 항 중 하나만 참이면, 참. 두 항이 모두 거짓이면, 거짓.( OR )
		* **!** 단항 연산자로 참인 경우는 거짓, 거짓인 경우는 참.( NOT )
		* **&&** 을 사용할 경우, 첫 항이 참이더라도 두번째 항이 거짓이면, 결과는 거짓이 된다. 첫 항이 무시됨.
		* **&#124;&#124;** 을 사용할 경우, 첫 항이 참이더라도 두번째 항이 거짓이면, 결과는 참이 된다. 두번째 항이 무시된다.
	* **복합 대입 연산자**
		* 대입연산자와 다른 연산자 조합해서 하나의 연산자처럼 사용.
		* **+=** 두 항의 값을 더해서 왼쪽 항에 저장. num+=2; 는 num = num+2; 와 같음.
		* **-=** 왼쪽 항에서 오른쪽 항을 뺴서 그 값을 왼쪽 항에 더함. num-=2; 는 num = num-2; 와 같음.
		* **&#42;=** 두 항을 곱해서 왼쪽 항에 저장. num&#42;=2; 는 num = num&#42;2;와 같음.
		* **/=** 왼쪽 항을 오른쪽 항으로 나눠서 그 몫을 왼쪽 항에 저장. num/=2; 는 num = num/2; 와 같음.
		* **%=** 왼쪽 항을 오른쪽 항으로 나누어 그 나머지를 왼쪽 항에 대입. num%=2; 는 num = num%2; 와 같음.
		* **<<=** 비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입.
		* **>>=** 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입.(왼쪽에 채워지는 비트 값은 부호 비트와 동일)
		* **&#62;&#62;&#62;=** 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입.(왼쪽에 채워지는 비트 값은 0)
		* **&=** 두 항의 & 비트 연산 후 그 값을 왼쪽 항에 대입.
		* **&#124;=** 두 항의 &#124;비트 연산 후 그 값을 왼쪽 항에 대입.
		* **^=** 두 항의 ^비트 연산 후 그 값을 왼쪽 항에 대입.
	* **조건 연산자**
		* 연산에 필요한 항의 개수가 3개. **삼항 연산자** 라고 한다.
	* **조건식? 결과1 : 결과2;** 조건식이 참이면 결과1이 실행. 거짓이면 결과2가 실행.

2. 비트 연산자
	* 비트 단위로 연산이 이루어지는 연산자.
	* 암호화 작업이나 마스킹 임베디드시스템 등에 사용.
	* **&연산자**
		* 두 개의 비트 값이 모두 1인 경우에만 결과 값 1이 도출 됨.
		* **5&10** 연산시, 5는 00000101(2) ,  10은 00001010(2) 인데, 연산 하면  모두 1인 경우가 없기에 00000000(2)이 된다.
	* **&#124;연산자**
		* 두 개의 비트 값 중에 하나라도 1이면 결과 값 1이 도출 됨.
		* **5&#124;10** 연산시, 5는 00000101(2) ,  10은 00001010(2) 인데, 연산하면 00001111(2)가 된다.
	* **^연산자**
		* 두 개의 비트 값이 같으면 0, 다르면 1의 결과 값 도출.
		* **5^10** 연산시, 5는 00000101(2) ,  10은 00001010(2) 인데, 연산하면 00001111(2)가 된다.
	* **~연산자**
		* 연산자는 비트 값을 0은 1로, 1은 0으로 바꾸는 연산자.
		* **5^10** 연산시, 5는 00000101(2) , 연산하면 11111010(2)가 된다.
	* **비트 이동연산자**
		* **<<연산자**
		* int num =5; , num<<2;  00000101(2)에서 00010100(2)가 된다.
		* **>>연산자**
		* 왼쪽에 채워지는 비트 값은 기존 값의 부호비트와 동일.
		* int num =10; , num>>2;  00001010(2)에서 00000010(2)가 된다.
	* **&#62;&#62;&#62;연산자**
		* 왼쪽에 채워지는 비트 값은 기존 값의 부호비트와 상관없이 무조건 0으로 채워짐.
		* int num =10; , num&#62;&#62;&#62;2;  00001010(2)에서 00000010(2)가 된다.
	* **연산자 우선순위**
		* 단항 연산자가 가장 높고, 이항, 삼항 연산자 순서.
		* 대입 연산자의 순서가 가장 낮음.
		* 산술,관계,논리,대입 연산자 순서로 우선순위가 정해지고, ()의 우선순위가 가장 높음.
